# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.remove_none_from_dict import remove_none_from_dict
from .resources.connect.client import AsyncConnectClient, ConnectClient
from .resources.users.client import AsyncUsersClient, UsersClient
from .types.activity import Activity
from .types.biometrics import Biometrics
from .types.body import Body
from .types.connected_user_info import ConnectedUserInfo
from .types.nutrition import Nutrition
from .types.sleep import Sleep
from .types.user import User


class DevicesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.connect = ConnectClient(client_wrapper=self._client_wrapper)
        self.users = UsersClient(client_wrapper=self._client_wrapper)

    def get_activity_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Activity]:
        """
        Returns activity data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "activity"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Activity], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_biometrics_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Biometrics]:
        """
        Returns biometrics data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "biometrics"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Biometrics], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_body_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Body]:
        """
        Returns body data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "body"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Body], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_nutrition_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Nutrition]:
        """
        Returns nutrition data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "nutrition"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Nutrition], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_sleep_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Sleep]:
        """
        Returns sleep data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sleep"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Sleep], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_user_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[User]:
        """
        Returns user info from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "user"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[User], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_connected_users(self) -> typing.List[ConnectedUserInfo]:
        """
        Returns a list of users with their IDs and connected providers.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "user"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ConnectedUserInfo], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncDevicesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.connect = AsyncConnectClient(client_wrapper=self._client_wrapper)
        self.users = AsyncUsersClient(client_wrapper=self._client_wrapper)

    async def get_activity_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Activity]:
        """
        Returns activity data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "activity"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Activity], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_biometrics_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Biometrics]:
        """
        Returns biometrics data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "biometrics"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Biometrics], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_body_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Body]:
        """
        Returns body data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "body"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Body], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_nutrition_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Nutrition]:
        """
        Returns nutrition data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "nutrition"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Nutrition], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_sleep_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[Sleep]:
        """
        Returns sleep data from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "sleep"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Sleep], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_user_data(self, *, user_id: str, date: str, timezone_id: str) -> typing.List[User]:
        """
        Returns user info from all of the specified users' connected providers.

        Parameters:
            - user_id: str. The Metriport user ID to create a session token for.

            - date: str. Day for which to pull the data. Formatted YYYY-MM-DD.

                         For simplicity, all queries assume the UTC timezone for the
                         specified date starting at 00:00 to 23:59 - unless otherwise
                         specified by the timezoneId parameter.

            - timezone_id: str. Timezone ID to use for the specified date. If not specified,
                                the UTC timezone is used. For example this can be valid timezones
                                like `America/Los_Angeles` or `Europe/Kiev`.

                                Valid timezones can be found at https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.

                                Support for this parameter is under development, and currently only supported for the Google Fit provider.

        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "user"),
            params=remove_none_from_dict({"userId": user_id, "date": date, "timezoneId": timezone_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[User], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_connected_users(self) -> typing.List[ConnectedUserInfo]:
        """
        Returns a list of users with their IDs and connected providers.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "user"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ConnectedUserInfo], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
