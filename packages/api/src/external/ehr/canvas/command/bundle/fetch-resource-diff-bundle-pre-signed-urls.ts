import CanvasApi, {
  isSupportedCanvasDiffResource,
  SupportedCanvasDiffResource,
  supportedCanvasDiffResources,
} from "@metriport/core/external/ehr/canvas/index";
import { BadRequestError } from "@metriport/shared";
import { ResourceDiffDirection } from "@metriport/shared/interface/external/ehr/resource-diff";
import { EhrSources } from "@metriport/shared/interface/external/ehr/source";
import { getPatientMappingOrFail } from "../../../../../command/mapping/patient";
import { createCanvasClient } from "../../shared";

export type FetchResourceDiffBundleParams = {
  cxId: string;
  canvasPracticeId: string;
  canvasPatientId: string;
  jobId: string;
  direction: ResourceDiffDirection;
  api?: CanvasApi;
  resourceType?: SupportedCanvasDiffResource;
};

export type FetchResourceDiffBundlePreSignedUrlsResult = {
  preSignedUrls: string[];
  resourceTypes: SupportedCanvasDiffResource[];
};

/**
 * Constructs a list of pre-signed URLs for the precomputed bundles of resources that are in Metriport and not in Canvas, or vice versa
 * by iterating over all supported resource types and fetching the pre-signed URL of the bundle for each resource type.
 * The bundles are generated by the resource diff workflow.
 *
 * @param cxId - The cxId of the patient.
 * @param canvasPracticeId - The canvas practice id of the patient.
 * @param canvasPatientId - The canvas patient id of the patient.
 * @param jobId - The id of the job that generated the precomputed bundles.
 * @param direction - The direction of the resource diff bundle to fetch.
 * @param api - The api to use to fetch the bundle. (optional)
 * @param resourceType - A single resource type to fetch. (optional, if missing, all supported resources will be fetched)
 * @returns The list of pre-signed URLs and the included resource types.
 */
export async function fetchCanvasResourceDiffBundlePreSignedUrls({
  cxId,
  canvasPracticeId,
  canvasPatientId,
  jobId,
  direction,
  api,
  resourceType: resourceTypeParam,
}: FetchResourceDiffBundleParams): Promise<FetchResourceDiffBundlePreSignedUrlsResult> {
  const existingPatient = await getPatientMappingOrFail({
    cxId,
    externalId: canvasPatientId,
    source: EhrSources.canvas,
  });
  const metriportPatientId = existingPatient.patientId;
  if (resourceTypeParam && !isSupportedCanvasDiffResource(resourceTypeParam)) {
    throw new BadRequestError("Resource type is not supported for bundle", undefined, {
      resourceType: resourceTypeParam,
    });
  }

  const preSignedUrls: string[] = [];
  const resourceTypes = resourceTypeParam ? [resourceTypeParam] : supportedCanvasDiffResources;
  let resourceTypesFound = [...resourceTypes];

  const canvasApi = api ?? (await createCanvasClient({ cxId, practiceId: canvasPracticeId }));
  for (const resourceType of resourceTypes) {
    const preSignedUrl = await canvasApi.getResourceDiffBundlePreSignedUrlByResourceType({
      cxId,
      metriportPatientId,
      canvasPatientId,
      resourceType,
      jobId,
      direction,
    });
    if (preSignedUrl) {
      preSignedUrls.push(preSignedUrl);
    } else {
      resourceTypesFound = resourceTypesFound.filter(rt => rt !== resourceType);
    }
  }
  return { preSignedUrls, resourceTypes: resourceTypesFound };
}
